from cmu_graphics import *
import random
from PIL import Image
#contains all of the classes for the auto-gen gamemode

class autoGeneratedMaze:
    def reset(self): #reset function to return maze to base state
        #called when the user reaches end to restart the maze
        self.board = [[0] * self.cols for i in range(self.rows)]
        self.verticalWalls = [[1] * (self.cols) for i in range(self.rows)]
        self.horizontalWalls = [[1] * (self.cols) for i in range(self.rows)]
        self.gameOver = False
        self.showSolution = False
        self.solution = []
        self.targetX = random.randint(0,self.cols - 1)
        self.targetY = random.randint(0,self.rows - 1)
        self.powerUp = False
        self.powerX = random.randint(0,self.cols - 1)
        self.powerY = random.randint(0,self.rows - 1)

    def __init__(self,x,y,width,height,rows,cols):
        self.xOffset = x
        self.yOffset = y
        self.width = width
        self.height = height
        self.cols = cols
        self.rows = rows
        self.cellLength = width//cols
        self.board = [[0] * self.cols for i in range(self.rows)]
        self.verticalWalls = [[1] * (self.cols) for i in range(self.rows)]
        self.horizontalWalls = [[1] * (self.cols) for i in range(self.rows)]
        self.gameOver = False
        self.showSolution = False
        self.solution = []
        self.score = 0
        self.targetX = random.randint(0,self.cols - 1)
        self.targetY = random.randint(0,self.rows - 1)
        self.exitImage = CMUImage(Image.open('exitPortal.png'))
        self.powerUp = False
        self.powerX = random.randint(0,self.cols - 1)
        self.powerY = random.randint(0,self.rows - 1)
        self.powerUpImage = CMUImage(Image.open('powerup.png'))

    def drawAutoMaze(self):
        
        drawLine(self.xOffset,self.yOffset,self.xOffset + self.width,self.yOffset)
        drawLine(self.xOffset,self.yOffset,self.xOffset,self.yOffset + self.width)

        for row in range(len(self.verticalWalls)): #draws vertical walls
            for col in range(len(self.verticalWalls[0])):
                if self.verticalWalls[row][col] == 1:
                    drawLine(self.xOffset + (col + 1)*self.cellLength,
                            self.yOffset + self.cellLength*row,
                            self.xOffset + (col + 1)*self.cellLength, 
                            self.yOffset + self.cellLength*(row+1))
                                
        for row in range(len(self.horizontalWalls)): #draws horizontal walls
            for col in range(len(self.horizontalWalls[0])):
                if self.horizontalWalls[row][col] == 1:
                    drawLine(self.xOffset + self.cellLength*col,
                             self.yOffset + self.cellLength*(row + 1),
                             self.xOffset + self.cellLength*(col+1),
                             self.yOffset + self.cellLength*(row + 1))
                    
    def getNeighbours(self,currCords,indexesVisited): #gets possible neighbours
        row,col = currCords #of a cell. Only returns which havent been visited
        neighbours = []
        for i in range(-1,2):
            for q in range(-1,2):
                if (0 in [i,q] and (i != q) 
                and (0 <= row + i < len(self.board)) 
                and (0 <= col + q < len(self.board[0]))
                and ((row + i,col + q) not in indexesVisited)):
                    neighbours.append((i,q))
        return neighbours

    def breakWall(self,curRow,curCol,changeRow,changeCol): #breakswall between 2 cells
        if changeRow == 1:
            self.horizontalWalls[curRow][curCol] = 0
        elif changeRow == -1:
            self.horizontalWalls[curRow - 1][curCol] = 0

        elif changeCol == 1:
            self.verticalWalls[curRow][curCol] = 0
    
        else:
            self.verticalWalls[curRow][curCol - 1] = 0


    def generateMaze(self): #This article helped me understand the maze generation algorithm https://www.algosome.com/articles/maze-generation-depth-first.html
        indexesVisited = set()
        queue = []
        currentCords = (0,0)

        while len(indexesVisited) != self.rows*self.cols: #till each cell is visited
            indexesVisited.add(currentCords)
            queue.append(currentCords)
            neighbours = self.getNeighbours(currentCords,indexesVisited)
                
            if len(neighbours) == 0: #if no legal moves
                queue.pop()
                currentCords = queue[-1]
                queue.pop() #resets curr to the last val, adjusts queue to ensure no repeats

            else: #breaks wall between a random neighbour and continues from there
                currRow,currCol = currentCords
                changeRow,changeCol = random.choice(neighbours)
                self.breakWall(currRow,currCol,changeRow,changeCol)
                currentCords = (currRow + changeRow,currCol + changeCol)


    def isMoveLegal(self,cords,drow,dcol): #used to see if the given move can 
        currRow,currCol = cords #can legally occur, accounts for the powerup
        newRow = currRow + drow #that lets you walk through walls
        newCol = currCol + dcol

        if not(0 <= newRow < self.rows) or not(0  <= newCol < self.cols):
            return False
        
        if 0 not in [drow,dcol] or drow == dcol:
            return False
        
        if self.powerUp:
            return True

        if dcol == 1:
            return self.verticalWalls[currRow][currCol] != 1
        elif dcol == -1:
            return self.verticalWalls[currRow][currCol - 1] != 1
        elif drow == 1:
            return self.horizontalWalls[currRow][currCol] != 1
        elif drow == -1:
            return self.horizontalWalls[currRow - 1][currCol] != 1
        
    def getposIndexes(self,cords): #gets all possible neighbours for the 
        row,col = cords #solving alg, like get neighbours but instead checks if there is a wall
        neighbours = []
        for i in range(-1,2):
            for j in range(-1,2):
                if self.isMoveLegal(cords,i,j):
                    neighbours.append((row + i,col + j))

        return neighbours 
     
    def findSolution(self,start = None, target = None): #i used the BFS algorithm which i found on page 4 of https://www.cs.cmu.edu/~112/notes/student-tp-guides/Pathfinding.pdf
        if target == None: #has None defaults for the target and start 
            target = (self.targetY,self.targetX) #to make the function adjustable
        if start == None: #to whatever you want it to find in the maze
            start = (0,0)

        queue = [start]
        visited = set()
        visited.add(start)
        nodesMovedDict = dict()

        while len(queue) != 0:
            frontNode = queue[-1]
            queue.pop()
            if frontNode == target:
                path = []
                while start not in path:
                    path.append(nodesMovedDict.get(frontNode))
                    if nodesMovedDict.get(frontNode)in nodesMovedDict:
                        frontNode = nodesMovedDict.get(frontNode)
                return path
            
            for n in self.getposIndexes(frontNode):
                if n not in visited:
                    visited.add(n)
                    queue.append(n)
                    nodesMovedDict[n] = frontNode

    def drawSol(self,path): #gets a path to the solution, draws it
        c = 0 #with a counter to display where to go first
        for x,y in path[::-1]:
            drawRect(self.xOffset + y*self.cellLength + 1,
                     self.yOffset + x*self.cellLength + 1,
                     self.cellLength - 2, self.cellLength - 2,
                     fill = 'lime')
            drawLabel(c,self.xOffset + (y + 0.5)*self.cellLength, 
                      self.yOffset + (x + 0.5)*self.cellLength,
                      size = self.cellLength - 3, font = 'monospace')
            c += 1
            
    def isGameOver(self,x,y): #checks if the game is over
        if x == self.targetX and y == self.targetY:
            self.score +=1 #if so, increments score and calls to reset the maze
            self.gameOver = True

    def drawGoal(self): #draws the portal
        drawImage(self.exitImage,
                  self.xOffset + self.cellLength * self.targetX,
                  self.yOffset + self.cellLength * self.targetY,
                  width = self.cellLength,height = self.cellLength)
    def drawPowerUp(self): #draws potion power up
        drawImage(self.powerUpImage,
                  self.xOffset + self.cellLength * self.powerX,
                  self.yOffset + self.cellLength * self.powerY,
                  width = self.cellLength,height = self.cellLength)


    def drawScore(self): #displays the score
        x = self.xOffset + 5
        y = 25
        drawRect(x,y,self.width - 10,50,fill = 'blue')
        drawLabel('Number of mazes',
                  x + (self.width - 20)/2,
                  75//2 + 5, 
                  font = 'monospace', fill = 'white', size = 15 )
        drawLabel(f'solved is {self.score}',
                  x + (self.width - 20)/2,
                  75//2 + 20, 
                  font = 'monospace', fill = 'white', size = 15 )
        
    def isPowerUp(self,x,y): #checks if powerup was used
        if x == self.powerX and y == self.powerY:
            self.powerUp = True
    
    def drawInstructions(self): #draws the instructions
        drawRect(50,310,300,80,fill = 'red')
        drawLabel('You goal is to the get to the end(portal)',
                  50 + 300/2,310 + 80//5,font = 'monospace',size = 10, 
                  fill = 'white', bold = True)
        drawLabel('You can map the way to the',
                  50 + 300/2,310 + 2 * 80//5,font = 'monospace',size = 10,
                  fill = 'white',bold = True)
        drawLabel(' goal by pressing a(answer) or h(hint))',
                  50 + 300/2,310 + 3 * 80//5,font = 'monospace',size = 10,
                  fill = 'white',bold = True)
        drawLabel('Potion is a powerup letting you walk through walls',
                  50 + 300/2,310 + 4 * 80//5,font = 'monospace',size = 10
                  ,fill = 'white',bold = True)
            
class autoGenPlayer:
    def reset(self): #resets player info, called when maze restarted
        self.xIndex = 0
        self.yIndex = 0
        self.Image = CMUImage(Image.open('penguinSprite.png'))  

    def __init__(self,x,y,length):
        self.x = x
        self.y = y
        self.length = length
        self.xIndex = 0
        self.yIndex = 0
        self.Image = CMUImage(Image.open('penguinSprite.png'))

    def drawPlayer(self): #draws player
        drawImage(self.Image,self.x + self.length * (self.xIndex),self.y + self.length*(self.yIndex) , width = self.length,height = self.length)
    

    def move(self,dx,dy,maze): #moves player is move is legal
        if maze.isMoveLegal((self.yIndex,self.xIndex),dy,dx):
            self.xIndex += dx
            self.yIndex += dy
            maze.isGameOver(self.xIndex,self.yIndex) #calls to check is gameover
            maze.isPowerUp(self.xIndex,self.yIndex)#or a powerup was found

        

   